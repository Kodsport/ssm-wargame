// Code generated by goa v3.5.2, DO NOT EDIT.
//
// challenge HTTP client CLI support package
//
// Command:
// $ goa gen github.com/sakerhetsm/ssm-wargame/internal/design -o internal/

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	challenge "github.com/sakerhetsm/ssm-wargame/internal/gen/challenge"
	goa "goa.design/goa/v3/pkg"
)

// BuildListChallengesPayload builds the payload for the challenge
// ListChallenges endpoint from CLI flags.
func BuildListChallengesPayload(challengeListChallengesView string, challengeListChallengesToken string) (*challenge.ListChallengesPayload, error) {
	var err error
	var view string
	{
		if challengeListChallengesView != "" {
			view = challengeListChallengesView
			if !(view == "default" || view == "author") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("view", view, []interface{}{"default", "author"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var token *string
	{
		if challengeListChallengesToken != "" {
			token = &challengeListChallengesToken
		}
	}
	v := &challenge.ListChallengesPayload{}
	v.View = view
	v.Token = token

	return v, nil
}

// BuildCreateChallengePayload builds the payload for the challenge
// CreateChallenge endpoint from CLI flags.
func BuildCreateChallengePayload(challengeCreateChallengeBody string, challengeCreateChallengeToken string) (*challenge.CreateChallengePayload, error) {
	var err error
	var body CreateChallengeRequestBody
	{
		err = json.Unmarshal([]byte(challengeCreateChallengeBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"A heap overflow challenge\",\n      \"score\": 50,\n      \"slug\": \"pwnme\",\n      \"title\": \"pwnme\"\n   }'")
		}
	}
	var token string
	{
		token = challengeCreateChallengeToken
	}
	v := &challenge.CreateChallengePayload{
		Slug:        body.Slug,
		Title:       body.Title,
		Description: body.Description,
		Score:       body.Score,
	}
	v.Token = token

	return v, nil
}

// BuildSubmitFlagPayload builds the payload for the challenge SubmitFlag
// endpoint from CLI flags.
func BuildSubmitFlagPayload(challengeSubmitFlagBody string, challengeSubmitFlagChallengeID string, challengeSubmitFlagToken string) (*challenge.SubmitFlagPayload, error) {
	var err error
	var body SubmitFlagRequestBody
	{
		err = json.Unmarshal([]byte(challengeSubmitFlagBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"flag\": \"SSM{flag}\"\n   }'")
		}
		if utf8.RuneCountInString(body.Flag) > 200 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.flag", body.Flag, utf8.RuneCountInString(body.Flag), 200, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var challengeID string
	{
		challengeID = challengeSubmitFlagChallengeID
		err = goa.MergeErrors(err, goa.ValidateFormat("challengeID", challengeID, goa.FormatUUID))

		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if challengeSubmitFlagToken != "" {
			token = &challengeSubmitFlagToken
		}
	}
	v := &challenge.SubmitFlagPayload{
		Flag: body.Flag,
	}
	v.ChallengeID = challengeID
	v.Token = token

	return v, nil
}
