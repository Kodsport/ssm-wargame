// Code generated by goa v3.5.2, DO NOT EDIT.
//
// admin HTTP server
//
// Command:
// $ goa gen github.com/sakerhetsm/ssm-wargame/internal/design -o internal/

package server

import (
	"context"
	"net/http"

	admin "github.com/sakerhetsm/ssm-wargame/internal/gen/admin"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// Server lists the admin service endpoint HTTP handlers.
type Server struct {
	Mounts                    []*MountPoint
	ListChallenges            http.Handler
	GetChallengeMeta          http.Handler
	CreateChallenge           http.Handler
	UpdateChallenge           http.Handler
	PresignChallFileUpload    http.Handler
	ListMonthlyChallenges     http.Handler
	DeleteMonthlyChallenge    http.Handler
	DeleteFile                http.Handler
	CreateMonthlyChallenge    http.Handler
	ListUsers                 http.Handler
	ListAuthors               http.Handler
	UpdateAuthor              http.Handler
	AddFlag                   http.Handler
	DeleteFlag                http.Handler
	ListCategories            http.Handler
	ChalltoolsImport          http.Handler
	ListCTFEvents             http.Handler
	CreateCTFEvent            http.Handler
	DeleteCTFEvent            http.Handler
	CreateCTFEventImportToken http.Handler
}

// ErrorNamer is an interface implemented by generated error structs that
// exposes the name of the error as defined in the design.
type ErrorNamer interface {
	ErrorName() string
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the admin service endpoints using the
// provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *admin.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) *Server {
	return &Server{
		Mounts: []*MountPoint{
			{"ListChallenges", "GET", "/admin/challenges"},
			{"GetChallengeMeta", "GET", "/admin/challenges/{challengeID}"},
			{"CreateChallenge", "POST", "/admin/challenges"},
			{"UpdateChallenge", "PUT", "/admin/challenges/{challengeID}"},
			{"PresignChallFileUpload", "POST", "/admin/challenges/{challengeID}/file_url"},
			{"ListMonthlyChallenges", "GET", "/admin/monthly_challenges"},
			{"DeleteMonthlyChallenge", "DELETE", "/admin/monthly_challenges/{challengeID}"},
			{"DeleteFile", "DELETE", "/admin/files/{fileID}"},
			{"CreateMonthlyChallenge", "POST", "/admin/monthly_challenges"},
			{"ListUsers", "GET", "/admin/users"},
			{"ListAuthors", "GET", "/admin/authors"},
			{"UpdateAuthor", "PUT", "/admin/authors/{id}"},
			{"AddFlag", "POST", "/admin/challenges/{challengeID}/flags"},
			{"DeleteFlag", "DELETE", "/admin/challenges/{challengeID}/flags/{flagID}"},
			{"ListCategories", "GET", "/admin/categories"},
			{"ChalltoolsImport", "POST", "/admin/push_challenge"},
			{"ListCTFEvents", "GET", "/admin/events"},
			{"CreateCTFEvent", "POST", "/admin/events"},
			{"DeleteCTFEvent", "DELETE", "/admin/events/{id}"},
			{"CreateCTFEventImportToken", "POST", "/admin/import_token"},
		},
		ListChallenges:            NewListChallengesHandler(e.ListChallenges, mux, decoder, encoder, errhandler, formatter),
		GetChallengeMeta:          NewGetChallengeMetaHandler(e.GetChallengeMeta, mux, decoder, encoder, errhandler, formatter),
		CreateChallenge:           NewCreateChallengeHandler(e.CreateChallenge, mux, decoder, encoder, errhandler, formatter),
		UpdateChallenge:           NewUpdateChallengeHandler(e.UpdateChallenge, mux, decoder, encoder, errhandler, formatter),
		PresignChallFileUpload:    NewPresignChallFileUploadHandler(e.PresignChallFileUpload, mux, decoder, encoder, errhandler, formatter),
		ListMonthlyChallenges:     NewListMonthlyChallengesHandler(e.ListMonthlyChallenges, mux, decoder, encoder, errhandler, formatter),
		DeleteMonthlyChallenge:    NewDeleteMonthlyChallengeHandler(e.DeleteMonthlyChallenge, mux, decoder, encoder, errhandler, formatter),
		DeleteFile:                NewDeleteFileHandler(e.DeleteFile, mux, decoder, encoder, errhandler, formatter),
		CreateMonthlyChallenge:    NewCreateMonthlyChallengeHandler(e.CreateMonthlyChallenge, mux, decoder, encoder, errhandler, formatter),
		ListUsers:                 NewListUsersHandler(e.ListUsers, mux, decoder, encoder, errhandler, formatter),
		ListAuthors:               NewListAuthorsHandler(e.ListAuthors, mux, decoder, encoder, errhandler, formatter),
		UpdateAuthor:              NewUpdateAuthorHandler(e.UpdateAuthor, mux, decoder, encoder, errhandler, formatter),
		AddFlag:                   NewAddFlagHandler(e.AddFlag, mux, decoder, encoder, errhandler, formatter),
		DeleteFlag:                NewDeleteFlagHandler(e.DeleteFlag, mux, decoder, encoder, errhandler, formatter),
		ListCategories:            NewListCategoriesHandler(e.ListCategories, mux, decoder, encoder, errhandler, formatter),
		ChalltoolsImport:          NewChalltoolsImportHandler(e.ChalltoolsImport, mux, decoder, encoder, errhandler, formatter),
		ListCTFEvents:             NewListCTFEventsHandler(e.ListCTFEvents, mux, decoder, encoder, errhandler, formatter),
		CreateCTFEvent:            NewCreateCTFEventHandler(e.CreateCTFEvent, mux, decoder, encoder, errhandler, formatter),
		DeleteCTFEvent:            NewDeleteCTFEventHandler(e.DeleteCTFEvent, mux, decoder, encoder, errhandler, formatter),
		CreateCTFEventImportToken: NewCreateCTFEventImportTokenHandler(e.CreateCTFEventImportToken, mux, decoder, encoder, errhandler, formatter),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "admin" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.ListChallenges = m(s.ListChallenges)
	s.GetChallengeMeta = m(s.GetChallengeMeta)
	s.CreateChallenge = m(s.CreateChallenge)
	s.UpdateChallenge = m(s.UpdateChallenge)
	s.PresignChallFileUpload = m(s.PresignChallFileUpload)
	s.ListMonthlyChallenges = m(s.ListMonthlyChallenges)
	s.DeleteMonthlyChallenge = m(s.DeleteMonthlyChallenge)
	s.DeleteFile = m(s.DeleteFile)
	s.CreateMonthlyChallenge = m(s.CreateMonthlyChallenge)
	s.ListUsers = m(s.ListUsers)
	s.ListAuthors = m(s.ListAuthors)
	s.UpdateAuthor = m(s.UpdateAuthor)
	s.AddFlag = m(s.AddFlag)
	s.DeleteFlag = m(s.DeleteFlag)
	s.ListCategories = m(s.ListCategories)
	s.ChalltoolsImport = m(s.ChalltoolsImport)
	s.ListCTFEvents = m(s.ListCTFEvents)
	s.CreateCTFEvent = m(s.CreateCTFEvent)
	s.DeleteCTFEvent = m(s.DeleteCTFEvent)
	s.CreateCTFEventImportToken = m(s.CreateCTFEventImportToken)
}

// Mount configures the mux to serve the admin endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountListChallengesHandler(mux, h.ListChallenges)
	MountGetChallengeMetaHandler(mux, h.GetChallengeMeta)
	MountCreateChallengeHandler(mux, h.CreateChallenge)
	MountUpdateChallengeHandler(mux, h.UpdateChallenge)
	MountPresignChallFileUploadHandler(mux, h.PresignChallFileUpload)
	MountListMonthlyChallengesHandler(mux, h.ListMonthlyChallenges)
	MountDeleteMonthlyChallengeHandler(mux, h.DeleteMonthlyChallenge)
	MountDeleteFileHandler(mux, h.DeleteFile)
	MountCreateMonthlyChallengeHandler(mux, h.CreateMonthlyChallenge)
	MountListUsersHandler(mux, h.ListUsers)
	MountListAuthorsHandler(mux, h.ListAuthors)
	MountUpdateAuthorHandler(mux, h.UpdateAuthor)
	MountAddFlagHandler(mux, h.AddFlag)
	MountDeleteFlagHandler(mux, h.DeleteFlag)
	MountListCategoriesHandler(mux, h.ListCategories)
	MountChalltoolsImportHandler(mux, h.ChalltoolsImport)
	MountListCTFEventsHandler(mux, h.ListCTFEvents)
	MountCreateCTFEventHandler(mux, h.CreateCTFEvent)
	MountDeleteCTFEventHandler(mux, h.DeleteCTFEvent)
	MountCreateCTFEventImportTokenHandler(mux, h.CreateCTFEventImportToken)
}

// MountListChallengesHandler configures the mux to serve the "admin" service
// "ListChallenges" endpoint.
func MountListChallengesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/admin/challenges", f)
}

// NewListChallengesHandler creates a HTTP handler which loads the HTTP request
// and calls the "admin" service "ListChallenges" endpoint.
func NewListChallengesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListChallengesRequest(mux, decoder)
		encodeResponse = EncodeListChallengesResponse(encoder)
		encodeError    = EncodeListChallengesError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListChallenges")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetChallengeMetaHandler configures the mux to serve the "admin" service
// "GetChallengeMeta" endpoint.
func MountGetChallengeMetaHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/admin/challenges/{challengeID}", f)
}

// NewGetChallengeMetaHandler creates a HTTP handler which loads the HTTP
// request and calls the "admin" service "GetChallengeMeta" endpoint.
func NewGetChallengeMetaHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetChallengeMetaRequest(mux, decoder)
		encodeResponse = EncodeGetChallengeMetaResponse(encoder)
		encodeError    = EncodeGetChallengeMetaError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "GetChallengeMeta")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateChallengeHandler configures the mux to serve the "admin" service
// "CreateChallenge" endpoint.
func MountCreateChallengeHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/admin/challenges", f)
}

// NewCreateChallengeHandler creates a HTTP handler which loads the HTTP
// request and calls the "admin" service "CreateChallenge" endpoint.
func NewCreateChallengeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateChallengeRequest(mux, decoder)
		encodeResponse = EncodeCreateChallengeResponse(encoder)
		encodeError    = EncodeCreateChallengeError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateChallenge")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateChallengeHandler configures the mux to serve the "admin" service
// "UpdateChallenge" endpoint.
func MountUpdateChallengeHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PUT", "/admin/challenges/{challengeID}", f)
}

// NewUpdateChallengeHandler creates a HTTP handler which loads the HTTP
// request and calls the "admin" service "UpdateChallenge" endpoint.
func NewUpdateChallengeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateChallengeRequest(mux, decoder)
		encodeResponse = EncodeUpdateChallengeResponse(encoder)
		encodeError    = EncodeUpdateChallengeError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateChallenge")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountPresignChallFileUploadHandler configures the mux to serve the "admin"
// service "PresignChallFileUpload" endpoint.
func MountPresignChallFileUploadHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/admin/challenges/{challengeID}/file_url", f)
}

// NewPresignChallFileUploadHandler creates a HTTP handler which loads the HTTP
// request and calls the "admin" service "PresignChallFileUpload" endpoint.
func NewPresignChallFileUploadHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodePresignChallFileUploadRequest(mux, decoder)
		encodeResponse = EncodePresignChallFileUploadResponse(encoder)
		encodeError    = EncodePresignChallFileUploadError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "PresignChallFileUpload")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListMonthlyChallengesHandler configures the mux to serve the "admin"
// service "ListMonthlyChallenges" endpoint.
func MountListMonthlyChallengesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/admin/monthly_challenges", f)
}

// NewListMonthlyChallengesHandler creates a HTTP handler which loads the HTTP
// request and calls the "admin" service "ListMonthlyChallenges" endpoint.
func NewListMonthlyChallengesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListMonthlyChallengesRequest(mux, decoder)
		encodeResponse = EncodeListMonthlyChallengesResponse(encoder)
		encodeError    = EncodeListMonthlyChallengesError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListMonthlyChallenges")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteMonthlyChallengeHandler configures the mux to serve the "admin"
// service "DeleteMonthlyChallenge" endpoint.
func MountDeleteMonthlyChallengeHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/admin/monthly_challenges/{challengeID}", f)
}

// NewDeleteMonthlyChallengeHandler creates a HTTP handler which loads the HTTP
// request and calls the "admin" service "DeleteMonthlyChallenge" endpoint.
func NewDeleteMonthlyChallengeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteMonthlyChallengeRequest(mux, decoder)
		encodeResponse = EncodeDeleteMonthlyChallengeResponse(encoder)
		encodeError    = EncodeDeleteMonthlyChallengeError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteMonthlyChallenge")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteFileHandler configures the mux to serve the "admin" service
// "DeleteFile" endpoint.
func MountDeleteFileHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/admin/files/{fileID}", f)
}

// NewDeleteFileHandler creates a HTTP handler which loads the HTTP request and
// calls the "admin" service "DeleteFile" endpoint.
func NewDeleteFileHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteFileRequest(mux, decoder)
		encodeResponse = EncodeDeleteFileResponse(encoder)
		encodeError    = EncodeDeleteFileError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteFile")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateMonthlyChallengeHandler configures the mux to serve the "admin"
// service "CreateMonthlyChallenge" endpoint.
func MountCreateMonthlyChallengeHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/admin/monthly_challenges", f)
}

// NewCreateMonthlyChallengeHandler creates a HTTP handler which loads the HTTP
// request and calls the "admin" service "CreateMonthlyChallenge" endpoint.
func NewCreateMonthlyChallengeHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateMonthlyChallengeRequest(mux, decoder)
		encodeResponse = EncodeCreateMonthlyChallengeResponse(encoder)
		encodeError    = EncodeCreateMonthlyChallengeError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateMonthlyChallenge")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListUsersHandler configures the mux to serve the "admin" service
// "ListUsers" endpoint.
func MountListUsersHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/admin/users", f)
}

// NewListUsersHandler creates a HTTP handler which loads the HTTP request and
// calls the "admin" service "ListUsers" endpoint.
func NewListUsersHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListUsersRequest(mux, decoder)
		encodeResponse = EncodeListUsersResponse(encoder)
		encodeError    = EncodeListUsersError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListUsers")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListAuthorsHandler configures the mux to serve the "admin" service
// "ListAuthors" endpoint.
func MountListAuthorsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/admin/authors", f)
}

// NewListAuthorsHandler creates a HTTP handler which loads the HTTP request
// and calls the "admin" service "ListAuthors" endpoint.
func NewListAuthorsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListAuthorsRequest(mux, decoder)
		encodeResponse = EncodeListAuthorsResponse(encoder)
		encodeError    = EncodeListAuthorsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListAuthors")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateAuthorHandler configures the mux to serve the "admin" service
// "UpdateAuthor" endpoint.
func MountUpdateAuthorHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PUT", "/admin/authors/{id}", f)
}

// NewUpdateAuthorHandler creates a HTTP handler which loads the HTTP request
// and calls the "admin" service "UpdateAuthor" endpoint.
func NewUpdateAuthorHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateAuthorRequest(mux, decoder)
		encodeResponse = EncodeUpdateAuthorResponse(encoder)
		encodeError    = EncodeUpdateAuthorError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "UpdateAuthor")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountAddFlagHandler configures the mux to serve the "admin" service
// "AddFlag" endpoint.
func MountAddFlagHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/admin/challenges/{challengeID}/flags", f)
}

// NewAddFlagHandler creates a HTTP handler which loads the HTTP request and
// calls the "admin" service "AddFlag" endpoint.
func NewAddFlagHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeAddFlagRequest(mux, decoder)
		encodeResponse = EncodeAddFlagResponse(encoder)
		encodeError    = EncodeAddFlagError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "AddFlag")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteFlagHandler configures the mux to serve the "admin" service
// "DeleteFlag" endpoint.
func MountDeleteFlagHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/admin/challenges/{challengeID}/flags/{flagID}", f)
}

// NewDeleteFlagHandler creates a HTTP handler which loads the HTTP request and
// calls the "admin" service "DeleteFlag" endpoint.
func NewDeleteFlagHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteFlagRequest(mux, decoder)
		encodeResponse = EncodeDeleteFlagResponse(encoder)
		encodeError    = EncodeDeleteFlagError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteFlag")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListCategoriesHandler configures the mux to serve the "admin" service
// "ListCategories" endpoint.
func MountListCategoriesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/admin/categories", f)
}

// NewListCategoriesHandler creates a HTTP handler which loads the HTTP request
// and calls the "admin" service "ListCategories" endpoint.
func NewListCategoriesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListCategoriesRequest(mux, decoder)
		encodeResponse = EncodeListCategoriesResponse(encoder)
		encodeError    = EncodeListCategoriesError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListCategories")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountChalltoolsImportHandler configures the mux to serve the "admin" service
// "ChalltoolsImport" endpoint.
func MountChalltoolsImportHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/admin/push_challenge", f)
}

// NewChalltoolsImportHandler creates a HTTP handler which loads the HTTP
// request and calls the "admin" service "ChalltoolsImport" endpoint.
func NewChalltoolsImportHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeChalltoolsImportRequest(mux, decoder)
		encodeResponse = EncodeChalltoolsImportResponse(encoder)
		encodeError    = EncodeChalltoolsImportError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ChalltoolsImport")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListCTFEventsHandler configures the mux to serve the "admin" service
// "ListCTFEvents" endpoint.
func MountListCTFEventsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/admin/events", f)
}

// NewListCTFEventsHandler creates a HTTP handler which loads the HTTP request
// and calls the "admin" service "ListCTFEvents" endpoint.
func NewListCTFEventsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListCTFEventsRequest(mux, decoder)
		encodeResponse = EncodeListCTFEventsResponse(encoder)
		encodeError    = EncodeListCTFEventsError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "ListCTFEvents")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateCTFEventHandler configures the mux to serve the "admin" service
// "CreateCTFEvent" endpoint.
func MountCreateCTFEventHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/admin/events", f)
}

// NewCreateCTFEventHandler creates a HTTP handler which loads the HTTP request
// and calls the "admin" service "CreateCTFEvent" endpoint.
func NewCreateCTFEventHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateCTFEventRequest(mux, decoder)
		encodeResponse = EncodeCreateCTFEventResponse(encoder)
		encodeError    = EncodeCreateCTFEventError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateCTFEvent")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteCTFEventHandler configures the mux to serve the "admin" service
// "DeleteCTFEvent" endpoint.
func MountDeleteCTFEventHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/admin/events/{id}", f)
}

// NewDeleteCTFEventHandler creates a HTTP handler which loads the HTTP request
// and calls the "admin" service "DeleteCTFEvent" endpoint.
func NewDeleteCTFEventHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteCTFEventRequest(mux, decoder)
		encodeResponse = EncodeDeleteCTFEventResponse(encoder)
		encodeError    = EncodeDeleteCTFEventError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DeleteCTFEvent")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateCTFEventImportTokenHandler configures the mux to serve the
// "admin" service "CreateCTFEventImportToken" endpoint.
func MountCreateCTFEventImportTokenHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/admin/import_token", f)
}

// NewCreateCTFEventImportTokenHandler creates a HTTP handler which loads the
// HTTP request and calls the "admin" service "CreateCTFEventImportToken"
// endpoint.
func NewCreateCTFEventImportTokenHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateCTFEventImportTokenRequest(mux, decoder)
		encodeResponse = EncodeCreateCTFEventImportTokenResponse(encoder)
		encodeError    = EncodeCreateCTFEventImportTokenError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateCTFEventImportToken")
		ctx = context.WithValue(ctx, goa.ServiceKey, "admin")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}
